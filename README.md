# goit-algo-hw-07
Homework for the topic “Trees and balancing”

Task_1_Напишіть алгоритм (функцію), який знаходить найбільше значення у двійковому дереві пошуку або в AVL-дереві.

  Теоретична частина
1. Двійкове дерево пошуку (BST):

 - Це структура даних, де для кожної вершини значення всіх елементів у лівому піддереві менші, а у правому — більші за значення поточної вершини.
 - Найбільше значення завжди знаходиться у крайньому правому вузлі дерева.

2. AVL-дерево:

 - Це самобалансоване двійкове дерево пошуку, де різниця висот лівого та правого піддерев для кожної вершини не перевищує 1.
 - Незважаючи на балансування, правила пошуку найбільшого значення такі ж, як у BST.

  Практична частина: Реалізація

Крок 1: Створення структури BST
Спочатку реалізуємо клас для дерева. Напишемо функціонал для вставки нових вузлів, а також функцію для пошуку найбільшого значення (дивимося виконаний код)
  Пояснення коду:
1. Клас Node:
 - Кожен вузол містить значення, а також посилання на лівого та правого нащадків.
2. Клас BinarySearchTree:
 - Включає методи для вставки елементів у дерево та пошуку найбільшого значення.
3. Метод insert:
 - Додає нове значення до дерева згідно з правилами BST.
4. Метод find_max:
 - Починаючи з кореня, ми переходимо до правих нащадків доти, доки не знайдемо вузол без правого нащадка (тобто найбільше значення).

Крок 2: Тестування коду ((дивимося виконаний код)

Крок 3: Пояснення результату

1. Створили дерево із такими значеннями: 50, 30, 70, 20, 40, 60, 80.
2. Метод find_max проходить по правих нащадках від кореня (50 → 70 → 80). 
3. Найправіший вузол має значення 80, яке і є результатом.
   Алгоритм правильно знаходить це значення, проходячи по правих нащадках.

Task_2_Напишіть алгоритм (функцію), який знаходить найменше значення у двійковому дереві пошуку або в AVL-дереві.

Пояснення:
1. Створили дерево із такими значеннями: 50, 30, 70, 20, 40, 60, 80.
2. Метод find_min проходить по лівих нащадках від кореня (50 → 30 → 20).
3. Найлівіший вузол має значення 20, яке і є результатом.

Task_3_Напишіть алгоритм (функцію), який знаходить суму всіх значень у двійковому дереві пошуку або в AVL-дереві.

Пояснення:
1. Створили дерево із такими значеннями: 50, 30, 70, 20, 40, 60, 80.
2. Функція calculate_sum використовує рекурсивний обхід дерева:
 - Вона додає значення поточного вузла до суми значень його лівого та правого піддерев.
3. Сума обчислюється як:
50 + (30 + (20 + 0 + 0) + (40 + 0 + 0)) + (70 + (60 + 0 + 0) + (80 + 0 + 0)) = 350

Task_3_необов'язкове_Реалізація системи коментарів з ієрархічною структурою

Пояснення коду:
1. Конструктор __init__:
 - Ініціалізує текст коментаря, автора, список відповідей та прапорець, що позначає видалений коментар.
2. Метод add_reply:
 - Додає новий коментар до списку відповідей поточного коментаря.
3. Метод remove_reply:
 - Змінює текст коментаря на "Цей коментар було видалено." і позначає його як видалений (is_deleted = True).
4. Метод display:
 - Виводить текст коментаря з відступами, залежно від рівня ієрархії. Рекурсивно викликає себе для кожної відповіді.

